-- 전체 초기화 (원하면 실행)
DELETE FROM questions;


-- =========================
-- CS (15)
-- =========================

INSERT INTO questions
(question_text, option_a, option_b, option_c, option_d, correct_answer, category)
VALUES
-- 1 (A) REST / API
('RESTful API에서 리소스 user의 “조회”에 가장 적절한 엔드포인트/메서드 조합은?',
 'GET /users/{id}',
 'POST /users/{id}',
 'PUT /users',
 'GET /users/create',
 'A', 'cs'),

-- 2 (B) HTTP/HTTPS
('로그인 요청에 포함된 민감 정보가 네트워크 중간에서 노출되지 않게 하는 핵심 차이는?',
 'HTTPS는 전송 구간을 TLS로 암호화한다',
 'HTTPS는 요청 바디를 자동으로 해시한다',
 'HTTP는 항상 압축을 사용한다',
 'HTTP는 쿠키를 지원하지 않는다',
 'B', 'cs'),

-- 3 (C) TCP vs UDP
('실시간 음성/영상처럼 지연이 치명적이고 일부 손실을 허용하는 통신에 더 적절한 선택은?',
 'TCP: 순서/재전송을 보장한다',
 'TCP: 혼잡 제어가 항상 더 빠르다',
 'UDP: 지연을 줄이고 손실을 일부 허용한다',
 'UDP: 반드시 암호화를 내장한다',
 'C', 'cs'),

-- 4 (D) DNS
('DNS 조회 결과를 로드밸런싱에 활용할 때 “DNS round-robin”의 한계로 가장 적절한 것은?',
 '서버는 하나의 IP만 등록할 수 있다',
 'HTTP 메서드에 따라 자동으로 분산된다',
 'TLS 연결이 기본적으로 차단된다',
 '리졸버/클라이언트 캐시로 분배가 고르게 되지 않을 수 있다',
 'D', 'cs'),

-- 5 (A) OS: process vs thread
('프로젝트에서 병렬 작업을 늘리려 합니다. 프로세스와 스레드 차이에 대한 설명으로 가장 정확한 것은?',
 '스레드는 같은 프로세스의 메모리 공간을 공유한다',
 '프로세스는 반드시 메모리를 공유한다',
 '스레드는 서로 완전히 분리된 주소 공간을 가진다',
 '프로세스는 컨텍스트 스위칭 비용이 없다',
 'A', 'cs'),

-- 6 (B) 동기/비동기
('“비동기”에 대한 설명으로 가장 적절한 것은?',
 '작업이 항상 병렬로 실행된다',
 '작업 완료를 기다리지 않고 다음 흐름을 진행할 수 있다',
 '작업이 반드시 더 빠르다',
 '작업이 항상 순차 실행된다',
 'B', 'cs'),

-- 7 (C) Critical Section
('멀티스레드 환경에서 공유 자원(예: 전역 카운터)을 안전하게 갱신하려 합니다. 가장 적절한 기본 해결책은?',
 '임계 구역을 없애기 위해 전역 변수를 더 늘린다',
 '스레드를 1개만 사용한다',
 '락/뮤텍스 등으로 임계 구역을 보호한다',
 'GC를 더 자주 돌린다',
 'C', 'cs'),

-- 8 (D) 자료구조: Stack/Queue
('웹 서버에서 요청을 “먼저 들어온 순서대로” 처리하는 큐잉이 필요합니다. 가장 적절한 자료구조는?',
 'Stack',
 'Tree',
 'Heap',
 'Queue',
 'D', 'cs'),

-- 9 (A) Hash collision
('해시테이블에서 충돌(collision) 해결 방식에 대한 설명으로 맞는 것은?',
 'Separate chaining은 버킷에 연결 리스트(또는 동등 구조)로 여러 항목을 저장한다',
 'Open addressing은 각 버킷에 연결 리스트를 둔다',
 'Separate chaining은 충돌이 아예 발생하지 않는다',
 'Open addressing은 리사이즈가 필요 없다',
 'A', 'cs'),

-- 10 (B) DB Index
('RDB에서 인덱스가 특히 효과적인 상황으로 가장 적절한 것은?',
 'WHERE 조건으로 특정 컬럼을 자주 조회하는 경우',
 'INSERT/UPDATE 작업이 끊임없이 매우 많이 발생하는 경우',
 '정규화를 최대한 하지 않고 하나의 테이블에 모든 데이터를 넣는 경우',
 '트랜잭션을 사용하지 않고 단순 로그만 기록하는 경우',
 'A', 'cs'),

-- 11 (C) Transaction/ACID
('트랜잭션 ACID 중 “Atomicity(원자성)”에 대한 설명으로 가장 적절한 것은?',
 '동시에 여러 트랜잭션이 실행될 수 있다',
 '데이터는 항상 최신 상태를 유지한다',
 '모두 성공하거나 모두 실패해야 한다',
 '장애가 나도 결과가 자동 복구된다',
 'C', 'cs'),

-- 12 (D) PreparedStatement
('Statement 대비 PreparedStatement의 장점으로 가장 적절한 것은?',
 '항상 네트워크 호출 횟수가 줄어든다',
 '모든 DB에서 성능이 무조건 2배 빨라진다',
 '트랜잭션을 자동으로 생성한다',
 '파라미터 바인딩으로 SQL 인젝션 위험을 줄이고 재사용에 유리하다',
 'D', 'cs'),

-- 13 (A) OOP vs FP (논란 적게, 정의형 최소)
('객체지향(OOP)의 핵심 의도에 가장 가까운 설명은?',
 '상태와 동작을 객체로 묶어 책임을 분리하고 변경 영향 범위를 줄인다',
 '모든 코드를 전역 함수로 구성한다',
 '데이터는 불변으로만 유지해야 한다',
 '상속을 최대한 많이 써야 한다',
 'A', 'cs'),

-- 14 (B) JavaScript Event Loop (프로젝트 직접 연관)
('브라우저/Node의 이벤트 루프에서 비동기 작업이 처리되는 흐름을 설명한 것으로 가장 적절한 것은?',
 '콜스택이 비어있을 때 태스크 큐에 대기 중인 콜백이 순서대로 실행된다',
 '비동기 함수는 실행 즉시 콜스택을 점유하여 다른 작업의 실행을 막는다',
 'Promise 콜백(Microtask)은 항상 setTimeout보다 나중에 실행된다',
 '이벤트 루프는 멀티스레드로 동작하여 네트워크 요청을 직접 병렬 처리한다',
 'A', 'cs'),

-- 15 (C) CORS (프로젝트 배포/인증 이슈와 직결)
('프론트(도메인 A)에서 백엔드(도메인 B)로 쿠키 포함 요청을 보내야 합니다. CORS 설정에 대한 설명으로 가장 적절한 것은?',
 'Access-Control-Allow-Origin을 *로 두면 credentials가 자동 허용된다',
 'credentials 요청에서는 allow-origin을 *로 두는 것이 가장 안전하다',
 'credentials 사용 시 allow-origin은 구체적 origin이어야 하고 allow-credentials도 필요하다',
 'CORS는 서버 성능 문제이므로 CDN으로 해결한다',
 'C', 'cs');

-- =========================
-- Git (15)
-- =========================

INSERT INTO questions
(question_text, option_a, option_b, option_c, option_d, correct_answer, category)
VALUES
-- 1 (A) fetch vs pull
('원격(dev)에 새 커밋이 올라왔는지 “먼저 확인만” 하고, 내 작업 브랜치는 건드리지 않으려 합니다. 가장 적절한 명령은?',
 'git fetch',
 'git pull',
 'git push',
 'git merge',
 'A','collab'),

-- 2 (B) staging 목적 (실전)
('하나의 파일에 “기능 수정”과 “로그 추가”가 섞여 있습니다. 기능 수정만 먼저 커밋하고 싶습니다. 가장 적절한 방법은?',
 'git add . 후 커밋 메시지로 구분한다',
 'git add -p 로 필요한 hunk만 stage 한다',
 '파일을 복사해서 두 개로 나눈다',
 'git commit --amend 로 나중에 분리한다',
 'B','collab'),

-- 3 (C) remote 연결 점검
('원격 저장소를 연결했는데 push가 엉뚱한 곳으로 갑니다. 현재 설정된 원격 URL을 확인하는 가장 적절한 명령은?',
 'git branch -vv',
 'git log --oneline',
 'git remote -v',
 'git status -sb',
 'C','collab'),

-- 4 (D) upstream 설정
('새로 만든 로컬 브랜치를 처음으로 원격에 올리면서 “추후부터는 git push만 해도 되게” 설정하고 싶습니다. 가장 적절한 명령은?',
 'git push origin HEAD',
 'git push --tags',
 'git push origin main',
 'git push -u origin <branch>',
 'D','collab'),

-- 5 (A) push 충돌(원격이 앞섬)
('git push가 거절됐고, 메시지에 “remote contains work that you do not have”가 포함됩니다. 내 로컬 커밋은 유지하면서 정상 흐름으로 맞추는 1차 대응은?',
 '원격 변경을 가져와서(merge/rebase) 충돌을 해결한 뒤 push한다',
 'git push --force 로 덮어쓴다',
 '원격 브랜치를 삭제하고 다시 만든다',
 '로컬을 reset --hard 해서 커밋을 버린다',
 'A','collab'),

-- 6 (B) amend의 영향(공유 여부 명시)
('방금 만든 커밋 메시지를 고치고 싶습니다. 아직 원격에 push하지 않았습니다. 가장 적절한 선택은?',
 'git commit --amend',
 'git revert HEAD',
 'git reset --hard HEAD~1',
 'git merge --abort',
 'B','collab'),

-- 7 (C) 이미 push한 커밋 amend 금기(논란 제거: 상황 명시)
('이미 PR이 열려 있고 팀원이 해당 브랜치를 기준으로 작업을 시작했습니다. 이때 “커밋을 amend 후 force push”가 특히 위험한 이유로 가장 적절한 것은?',
 '브랜치 이름이 바뀐다',
 'PR이 자동으로 닫힌다',
 '팀원이 가진 커밋 기반이 달라져 히스토리/충돌이 꼬일 수 있다',
 'GitHub가 저장소를 잠근다',
 'C','collab'),

-- 8 (D) PR에서 섞인 변경(리뷰 관점)
('PR에 “기능 변경”과 “리포맷/리팩토링”이 섞여 리뷰가 어렵습니다. 가장 협업 친화적인 개선은?',
 '리뷰어가 알아서 보게 둔다',
 '커밋 수를 1개로 합친다',
 '파일을 더 많이 쪼갠다',
 '의도 기준으로 PR/커밋을 분리해 변경 단위를 작게 만든다',
 'D','collab'),

-- 9 (A) merge conflict 예방(전제 제거: dev 최신화 방식은 팀 규칙에 따름)
('내 feature 브랜치가 오래되어 dev와 충돌이 예상됩니다. PR 전에 “충돌을 내가 책임지고 먼저 해결”하려면 가장 적절한 흐름은?',
 'dev 최신을 내 브랜치로 가져와(merge 또는 rebase) 충돌을 해결한 뒤 PR을 올린다',
 'PR 올리고 충돌은 리뷰어가 해결하게 한다',
 '충돌은 GitHub가 자동으로 해결해주길 기다린다',
 '파일을 삭제하고 다시 만든다',
 'A','collab'),

-- 10 (B) main 복구
('main에 잘못된 변경이 머지되었고, 그 뒤로도 main에 정상 커밋이 추가로 들어갔습니다. “히스토리를 깨지 않고” 되돌리는 가장 안전한 방식은?',
 'main을 reset --hard로 되돌리고 force push한다',
 'git revert 로 되돌리는 커밋을 추가한다',
 'rebase로 해당 커밋을 제거한다',
 'origin/main을 삭제 후 재생성한다',
 'B','collab'),

-- 11 (C) pull = fetch+merge 개념 응용
('팀원이 “로컬은 최신인데 원격이 더 앞서 있다”고 말합니다. 실제로 원격의 변경만 확인하고 싶다면 가장 적절한 흐름은?',
 'git pull 후 로그를 본다',
 'git push 후 비교한다',
 'git fetch 후 비교(log/branch -vv 등)한다',
 'git commit --amend 후 확인한다',
 'C','collab'),

-- 12 (D) remote rename/관리 (협업 준비도)
('팀에서 원격 이름을 origin이 아니라 upstream으로 통일하기로 했습니다. 기존 origin 이름을 upstream으로 바꾸는 가장 적절한 명령은?',
 'git remote add upstream <url>',
 'git remote -v upstream',
 'git remote remove origin',
 'git remote rename origin upstream',
 'D','collab'),

-- 13 (A) clone vs init (실수 방지)
('기존 원격 저장소를 새 컴퓨터로 가져와 동일한 히스토리로 작업하려 합니다. 가장 적절한 시작 방법은?',
 'git clone <repo-url>',
 'git init 후 파일을 복사한다',
 '새 repo를 만들어 push한다',
 'zip으로 내려받아 붙여넣는다',
 'A','collab'),

-- 14 (B) staging 취소/되돌리기 (실전)
('실수로 stage에 올렸지만 커밋 전입니다. 작업 내용은 유지하고 stage만 내리고 싶습니다. 가장 적절한 선택은?',
 'git reset',
 'git restore --staged <file>',
 'git checkout -- <file>',
 'git clean -fd',
 'B','collab'),

-- 15 (C) 보호 규칙(준비도)
('팀 프로젝트에서 “직접 main/dev push로 사고”가 반복됩니다. 가장 구조적인 예방책은?',
 '규칙을 회의에서 다시 공유한다',
 '커밋 메시지 템플릿을 바꾼다',
 '브랜치 보호 규칙으로 direct push를 막고 PR만 허용한다',
 '레포를 개인 레포로 바꾼다',
 'C','collab');



-- =========================
-- AI (20) : 상용 AI 12 / 로컬 3 / 기초 5
-- =========================

INSERT INTO questions
(question_text, option_a, option_b, option_c, option_d, correct_answer, category)
VALUES

-- [상용 AI - 서비스(3)]
(
'상용 LLM API를 서비스에 연동했는데 특정 시간대에 지연/타임아웃이 늘어납니다. 운영 관점에서 가장 먼저 넣어야 할 복원력(Resiliency) 설계는?',
'지수 백오프 + 재시도 상한 + 타임아웃을 두고, 실패 시 대체 응답(Fallback) 경로를 마련한다',
'동시 요청 수 제한을 완전히 해제하여 처리량으로 지연을 상쇄한다',
'모든 요청을 무조건 더 큰 파라미터의 모델로 올려서 해결한다',
'재시도를 금지하고 실패 시 즉시 에러만 반환해 장애를 방치한다',
'A', 'ai'
),
(
'자주 반복되는 사용자 질문 때문에 LLM 호출 비용이 급증했습니다. 품질을 크게 훼손하지 않으면서 비용을 줄이는 접근으로 가장 적절한 것은?',
'응답 길이를 줄이기 위해 모든 질문의 temperature를 무조건 0으로 고정한다',
'유사 질문을 의미 기준으로 묶어 기존 응답을 재사용하는 시맨틱 캐싱(Semantic Caching)을 적용한다',
'입력 토큰을 강제로 대폭 자르고 부족한 정보는 모델의 사전 지식으로만 추론하게 한다',
'모든 실시간 트래픽을 검증되지 않은 소형 파인튜닝 모델로 즉시 전환한다',
'B', 'ai'
),
(
'LLM API 키 노출을 막기 위한 설계로 가장 적절한 것은?',
'프론트엔드 빌드 환경 변수에 키를 넣고 클라이언트 번들에 직접 주입한다',
'클라이언트에서 키를 암호화해 브라우저의 localStorage에 저장한다',
'브라우저가 공급자 API를 직접 호출하게 하고 모든 요청 헤더에 키를 노출한다',
'서버(API Route/Backend)에서만 키를 보관하고, 클라이언트는 서버 엔드포인트를 호출한다',
'D', 'ai'
),

-- [상용 AI - 에이전트(2)]
(
'다음 중 AI “에이전트(Agent)”의 특징을 가장 잘 설명한 것은?',
'사용자 질문을 특정 카테고리로 분류만 하는 단순 분류기',
'목표 달성을 위해 상태를 유지하며 도구를 선택/호출하고 결과를 반영해 다음 행동을 결정하는 시스템',
'대규모 문서를 단순히 하나로 합쳐서 요약만 수행하는 모델',
'정해진 답변 템플릿에 따라 텍스트만 출력하는 고정형 챗봇',
'B', 'ai'
),
(
'에이전트가 “추론-행동-관찰”을 반복하며 도구 호출 결과를 반영해 다음 행동을 조정하는 프롬프팅 방식은?',
'Few-shot Prompting',
'Self-Consistency',
'ReAct (Reasoning and Acting)',
'Chain of Thought (단독 사용)',
'C', 'ai'
),

-- [상용 AI - MCP(1)]
(
'MCP(Model Context Protocol)를 도입했을 때 기대할 수 있는 이점으로 가장 적절한 것은?',
'다양한 데이터 소스와 도구 연결을 표준화하여 모델이 일관된 방식으로 컨텍스트에 접근하게 한다',
'모델의 내부 가중치를 실시간으로 수정하여 기본 정확도를 물리적으로 높인다',
'프롬프트 길이를 자동으로 압축하여 토큰 사용량을 90% 이상 강제 절감한다',
'모델의 TPS(초당 토큰 생성량) 하드웨어 성능을 비약적으로 증가시킨다',
'A', 'ai'
),

-- [상용 AI - RAG(3)]
(
'RAG에서 “검색된 문서 내용은 맞는데” 최종 답변이 문서와 다르게 엉뚱하게 나옵니다. 우선 점검해야 할 지점은?',
'벡터 DB의 인덱스 타입(HNSW 등)을 다른 알고리즘으로 변경해 본다',
'임베딩 모델의 차원을 더 축소하여 검색 속도를 극대화한다',
'생성 단계에서 근거 기반 답변을 강제하는 프롬프트 지시문과 컨텍스트 인용 방식을 점검한다',
'문서 수집 크롤러의 성능을 높여 데이터의 양을 무조건 늘린다',
'C', 'ai'
),
(
'시맨틱 검색만으로 고유명사나 키워드 정밀도가 부족할 때, 이를 보완하는 구성으로 가장 적절한 것은?',
'임베딩 모델을 더 큰 모델로 바꾸고 Top-k 값을 무제한으로 늘린다',
'BM25 키워드 검색과 벡터 검색을 결합한 하이브리드 검색에 Reranker를 붙여 재정렬한다',
'모든 문서를 쪼개지 않고 하나의 거대한 청크로 합쳐서 검색에 사용한다',
'검색 단계를 완전히 생략하고 모델의 자체 학습 지식에만 전적으로 의존한다',
'B', 'ai'
),
(
'RAG에서 모델이 문서에 없는 내용을 사실인 것처럼 생성합니다. 이를 방지하는 설계로 가장 적절한 것은?',
'Temperature를 1.0 이상으로 높여 답변의 무작위성을 최대화한다',
'문서 내용이 부족하더라도 모델이 추측해서 반드시 답하도록 지시를 강화한다',
'검색된 문서의 양이 많을수록 좋으므로 무조건 Top-k를 100 이상으로 키운다',
'“근거 문서에 없는 내용은 모른다고 답하기” 지시와 답변-근거 정합성 검증 절차를 함께 둔다',
'D', 'ai'
),

-- [상용 AI - 일반/운영(3)]
(
'결제/삭제 같은 고위험 작업을 에이전트에 맡길 때 가장 권장되는 안전장치는?',
'실행 전 최종 단계에서 사람의 승인을 요구하는 Human-in-the-loop 단계를 배치한다',
'에이전트가 생성한 확신 점수(Confidence)가 낮을 때만 무조건 재시도하게 한다',
'도구를 최대한 많이 연결하여 에이전트가 스스로 실수를 교정할 확률을 높인다',
'사용자의 편의성을 위해 모든 실행 로그를 남기지 않고 자동화한다',
'A', 'ai'
),
(
'에이전트가 동일한 툴을 반복 호출하며 종료되지 않는 현상이 발생할 때, 가장 먼저 점검할 요소는?',
'프론트엔드 프레임워크의 렌더링 최적화 설정',
'데이터베이스 커넥션 풀의 최대 허용 수치',
'API 공급자의 일일 호출 쿼터 제한 설정',
'최대 반복 횟수(Max Iterations) 설정 및 종료 조건이 정상적으로 업데이트되는지',
'D', 'ai'
),
(
'배포 전에 프롬프트 변경이 품질에 미치는 영향을 정량적으로 비교하는 가장 신뢰도 높은 방법은?',
'개발자 한 명이 몇 가지 질문을 임의로 던져보고 주관적으로 판단한다',
'실제 운영 환경의 모든 로그를 전수 조사하여 수동으로 합격점을 준다',
'대표 테스트셋(Golden set)과 루브릭을 정의하여 동일 조건에서 반복 평가하고 지표를 비교한다',
'프롬프트의 글자 수가 가장 짧은 쪽이 항상 우수하다고 판단한다',
'C', 'ai'
),

-- [로컬 AI(3)]
(
'제한된 VRAM 환경에서 로컬 LLM을 구동하기 위해 가중치 정밀도를 낮춰 메모리 사용량을 줄이는 기법은?',
'양자화(Quantization: 8-bit/4-bit 등)',
'지식 증류(Knowledge Distillation)',
'파인튜닝(Fine-tuning)',
'가중치 초기화(Initialization)',
'A', 'ai'
),
(
'로컬 LLM에서 GPU 가속이 기대보다 나오지 않을 때, “우선순위가 가장 낮은” 점검 항목은?',
'CUDA/드라이버 버전과 딥러닝 프레임워크 간의 호환성 여부',
'모델의 레이어가 실제로 GPU 메모리에 정상 로드되어 연산되는지 확인',
'vLLM이나 Flash-Attention 같은 추론 최적화 엔진의 적용 여부',
'CPU의 물리 스레드 수를 2배로 늘리면 GPU 연산 병목이 자동으로 사라지는지 확인',
'D', 'ai'
),
(
'로컬 LLM 운영 중 OOM(Out of Memory)이 빈번하게 발생할 때 취할 즉각적인 조치로 적절한 것은?',
'모델을 더 큰 파라미터 모델로 교체하여 처리 능력을 키운다',
'컨텍스트 윈도우 크기나 배치 사이즈를 줄이고 더 강한 양자화 모델을 사용한다',
'Temperature를 낮추면 발열이 줄어들어 하드웨어 메모리가 추가로 확보된다',
'시스템 폰트와 배경화면 설정을 변경하여 비디오 메모리를 점유한다',
'B', 'ai'
),

-- [AI 기초 상식(5)]
(
'토큰(Token)에 대한 설명으로 가장 옳은 것은?',
'항상 띄어쓰기 단어 단위와 1:1로 매칭되는 고정 길이 단위이다',
'토큰의 개수는 항상 입력한 텍스트의 글자 수와 일치한다',
'모델이 처리하는 최소 단위로 단어의 일부, 공백, 기호 등이 포함될 수 있다',
'이미지 데이터의 해상도(픽셀 수)를 의미하는 전문 용어이다',
'C', 'ai'
),
(
'Temperature 파라미터가 모델 출력에 미치는 영향으로 가장 적절한 것은?',
'다음 토큰 예측 확률 분포의 선명도를 조절해 출력의 무작위성과 다양성을 제어한다',
'모델이 사전에 학습한 지식의 절대적인 양을 실시간으로 확장한다',
'한 번에 입력 가능한 컨텍스트의 최대 길이를 하드웨어적으로 결정한다',
'API의 물리적인 네트워크 왕복 지연 시간(Latency)을 고정한다',
'A', 'ai'
),
(
'임베딩(Embedding) 모델의 역할로 가장 적절한 것은?',
'사용자의 복잡한 질문에 대해 자연어 문장으로 최종 답변을 생성한다',
'데이터베이스의 스키마를 분석하여 SQL 쿼리를 자동으로 작성한다',
'텍스트 등 데이터를 고차원 벡터로 변환하여 의미적 유사도 비교를 가능하게 한다',
'프로그래밍 코드의 로직 오류를 찾아내고 실시간으로 패치한다',
'C', 'ai'
),
(
'사용자 입력에 악의적인 지시를 포함해 시스템의 원래 지침을 우회하려는 보안 공격은?',
'SQL 인젝션',
'프롬프트 인젝션(Prompt Injection)',
'크로스 사이트 스크립팅(XSS)',
'중간자 공격(MITM)',
'B', 'ai'
),
(
'TTFT(Time To First Token) 지표가 서비스 사용자 경험에서 의미하는 바는?',
'전체 답변 생성이 완료될 때까지 소요된 총 시간',
'모델이 초당 생성해내는 평균 토큰의 개수',
'모델을 학습(Training)시키기 위해 투입된 총 컴퓨팅 시간',
'요청 후 첫 번째 토큰이 출력되기까지 걸린 시간(체감 응답 속도)',
'D', 'ai'
);